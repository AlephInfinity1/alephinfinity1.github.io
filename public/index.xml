<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Redpo&#39;s Catalogue</title>
        <link>http://localhost:1313/</link>
        <description>Recent content on Redpo&#39;s Catalogue</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 13 May 2024 13:15:25 +0800</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[Tutorial] The sparse set data structure</title>
        <link>http://localhost:1313/post/sparse_set_ds/sparse_set_ds/</link>
        <pubDate>Sun, 24 Mar 2024 17:09:01 +0800</pubDate>
        
        <guid>http://localhost:1313/post/sparse_set_ds/sparse_set_ds/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://codeforces.com/blog/entry/127472&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[Tutorial] The sparse set data structure - Codeforces&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Original post: &lt;a class=&#34;link&#34; href=&#34;https://codeforces.com/blog/entry/127472&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://codeforces.com/blog/entry/127472&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hello, Codeforces!&lt;/p&gt;
&lt;p&gt;I recently came across a data structure that I find quite interesting: theÂ &lt;strong&gt;sparse set&lt;/strong&gt;. It functions similarly to a bitset and supports all its operations but has some quirks and useful features of its own. Particularly, unlike almost every other data structure, it does not need to beÂ &lt;em&gt;initialised&lt;/em&gt;Â at all before it can be used! Naturally, that also means that its data can be reset inÂ $\mathcal O(1)$Â time, as opposed to theÂ $\mathcal O(n)$Â time expected of regular bitsets. It also has the added benefit that traversing its elements takes time proportional to the number of elements rather than the size of the data structure, making the operation more efficient for sparse bitsets. However, note that it is likely less efficient in terms of its memory usage (stillÂ $\mathcal O(n)$Â but ~64Ã— larger constant) and constant time factor.&lt;/p&gt;
&lt;h1 id=&#34;introduction&#34;&gt;
    &lt;a href=&#34;#introduction&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Introduction
&lt;/h1&gt;&lt;p&gt;The sparse set consists simply of two integer arrays (which I&amp;rsquo;ll callÂ $d$Â andÂ $s$) and a size variableÂ $n$, satisfying the following class invariants:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Invariant 1&lt;/strong&gt;:Â ğ‘‘[0..(ğ‘›âˆ’1)]Â (inclusive) stores the elements of the bitset;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Invariant 2&lt;/strong&gt;: IfÂ ğ‘’Â is an element of the bitset, thenÂ ğ‘ [ğ‘’]Â stores its index in theÂ ğ‘‘Â array.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In most literature covering this data structure, the arraysÂ $d$Â andÂ $s$Â are called the &amp;lsquo;dense&amp;rsquo; and the &amp;lsquo;sparse&amp;rsquo; arrays, respectively.&lt;/p&gt;
&lt;p&gt;For any array element not mentioned above, its value can beÂ &lt;em&gt;anything&lt;/em&gt;Â without affecting the function of the data structure.&lt;/p&gt;
&lt;p&gt;A typical sparse set might look like this (asterisk denotes terms that can be anything):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/post/sparse_set_ds/example.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;An example sparse set&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;The red lines indicate the connections between the elements inÂ ğ‘‘Â andÂ ğ‘ . It can be shown that, for all indicesÂ ğ‘–Â in the rangeÂ [0,ğ‘›âˆ’1], the constraintÂ ğ‘‘[ğ‘ [ğ‘‘[ğ‘–]]]=ğ‘‘[ğ‘–]Â is satisfied.&lt;/p&gt;
&lt;p&gt;In C++ code, the data structure can be represented as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sparse_set&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; d[N], s[N];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that, in this article, we would useÂ ğ‘Â to denote the size of the data structure itself (and thus, the set of elements allowed isÂ 0,1,â€¦,ğ‘âˆ’1), andÂ ğ‘›Â to denote the number of elements currently stored.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important implementation detail&lt;/strong&gt;: if you are using C, C++, or Rust, you stillÂ &lt;em&gt;have&lt;/em&gt;Â to initialise this data structure in its constructor since accessing an uninitialised element does not return an unspecified value; it is undefined behaviour and can introduce bugs elsewhere in your program. You don&amp;rsquo;t have to do this when resetting the data structure, however.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Example one-line constructor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sparse_set(): n{0}, d{}, s{} {}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;lookup&#34;&gt;
    &lt;a href=&#34;#lookup&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Lookup
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Precondition&lt;/strong&gt;:Â ğ‘–ğ‘‘ğ‘¥Â is a value betweenÂ 0Â andÂ ğ‘âˆ’1;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Postcondition&lt;/strong&gt;: the data structure is unmodified, andÂ ğ‘–ğ‘‘ğ‘¥&amp;rsquo;s presence in the bitset is returned.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time cost&lt;/strong&gt;: ğ‘‚(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Surely, sinceÂ ğ‘ [ğ‘–]Â stores the position of elementÂ ğ‘– inÂ ğ‘‘, I can simply check ifÂ ğ‘ [ğ‘–]Â is betweenÂ 0Â andÂ ğ‘›âˆ’1Â to determine whetherÂ ğ‘–Â is in the bitset, right?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Intentionally incorrect code!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;test(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Not reallyâ€¦ it is entirely possible thatÂ ğ‘–Â is not in the set, yetÂ ğ‘ [ğ‘–]Â has a &amp;lsquo;valid&amp;rsquo; value betweenÂ 0Â andÂ ğ‘›âˆ’1Â since the data structure specifies no guarantees for values ofÂ ğ‘ [ğ‘–]Â whereÂ ğ‘–Â is not an element; therefore false positives might arise. We have to check if the value ofÂ ğ‘‘[ğ‘ [ğ‘–]]Â linksÂ &lt;em&gt;back&lt;/em&gt;Â to the correct value ofÂ ğ‘–.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/post/sparse_set_ds/lookup_wrong.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Incorrect lookup&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Here, 6 isn&amp;rsquo;t actually stored in the data structure, butÂ ğ‘ [6]Â happened to be a &amp;lsquo;correct&amp;rsquo; index, misleading our erroneous algorithm to think that it is.&lt;/p&gt;
&lt;p&gt;The correct implementation of the lookup operation would look something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;test(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; d[s[idx]] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; idx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;insertion&#34;&gt;
    &lt;a href=&#34;#insertion&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Insertion
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Precondition&lt;/strong&gt;:Â ğ‘–ğ‘‘ğ‘¥Â is an integer betweenÂ 0Â andÂ ğ‘âˆ’1.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Postcondition&lt;/strong&gt;:Â ğ‘–ğ‘‘ğ‘¥Â is inserted into the data structure if and only if it wasn&amp;rsquo;t already present.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time cost&lt;/strong&gt;: ğ‘‚(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Just like normal bitsets, our implementation does not allow duplicate elements. Therefore, we have to check whether the element is present before inserting. Inserting an element is a rather simple operation: if the element is not already present, we push its value onto theÂ ğ‘‘Â array, updateÂ ğ‘ [ğ‘–ğ‘‘ğ‘¥]Â to the correct value, and then increment the value ofÂ ğ‘›Â byÂ 1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/post/sparse_set_ds/insert.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Insertion&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;The code to do this would look a bit like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;set(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (test(idx)) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    d[n] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;deletion&#34;&gt;
    &lt;a href=&#34;#deletion&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Deletion
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Precondition&lt;/strong&gt;:Â ğ‘–ğ‘‘ğ‘¥Â is an index betweenÂ 0Â andÂ ğ‘âˆ’1.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Postcondition&lt;/strong&gt;: ifÂ ğ‘–ğ‘‘ğ‘¥Â was inside the set, it is now removed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time cost&lt;/strong&gt;:Â ğ‘‚(1).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As the inverse operation of insertion, deletion is slightly more complex to implement than insertion but is nevertheless still rather straightforward. The central idea is to swap the last element with the element to be deleted in theÂ ğ‘‘Â array, then update the corresponding values inÂ ğ‘ Â accordingly.&lt;/p&gt;
&lt;p&gt;Basic procedure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We want to makeÂ ğ‘–ğ‘‘ğ‘¥Â the new position for our last element, therefore changeÂ ğ‘ [ğ‘‘[ğ‘›âˆ’1]]Â toÂ ğ‘ [ğ‘–ğ‘‘ğ‘¥].&lt;/li&gt;
&lt;li&gt;OverwriteÂ ğ‘‘[ğ‘ [ğ‘–ğ‘‘ğ‘¥]]Â with the value ofÂ ğ‘‘[ğ‘›âˆ’1].&lt;/li&gt;
&lt;li&gt;DecrementÂ ğ‘›Â byÂ 1.&lt;/li&gt;
&lt;li&gt;No need to modifyÂ ğ‘ [ğ‘–ğ‘‘ğ‘¥]Â since the class invariant doesn&amp;rsquo;t care aboutÂ ğ‘ [ğ‘’]Â for deleted elementsÂ ğ‘’.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The diagram for doing the above operations would look a bit like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/post/sparse_set_ds/delete.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Deletion&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Note that the above procedure still works when the element being deleted is the last element in theÂ ğ‘‘Â array, albeit with extra steps. However, since deletions to the last element are rare, it is not worth adding a branch to check for this condition.&lt;/p&gt;
&lt;p&gt;Therefore, the code for this operation would look as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;reset(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;test(idx)) {&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  d[s[idx]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; d[n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  s[d[n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s[idx];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  n&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;clearance&#34;&gt;
    &lt;a href=&#34;#clearance&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Clearance
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Precondition&lt;/strong&gt;: None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Postcondition&lt;/strong&gt;: the bitset is cleared. Before modifications,Â &lt;code&gt;.get(i)&lt;/code&gt;Â returns false for all validÂ ğ‘–.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time cost&lt;/strong&gt;: ğ‘‚(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Out of all the operations that the sparse set supports, this is arguably the most powerful, taking onlyÂ ğ‘‚(1)Â time to compute, with an extremely simple implementation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/post/sparse_set_ds/clear.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Clearance&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;This is literally everything that has to be done :)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;reset() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;iteration&#34;&gt;
    &lt;a href=&#34;#iteration&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Iteration
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Precondition&lt;/strong&gt;: None&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Postcondition&lt;/strong&gt;: Iterates through the elements of the bitset.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time cost&lt;/strong&gt;:Â ğ‘‚(ğ‘›)Â (note:Â ğ‘›Â is the number of elements present. This is different fromÂ ğ‘‚(ğ‘)Â whereÂ ğ‘Â is the size of the container)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is another operation where the sparse set is better than the classic bitset. Rather than iterating bit-by-bit and checking whether each element is present, we can simply iterate throughÂ ğ‘‘[0..(ğ‘›âˆ’1)]Â (inclusive) to obtain the list of elements present in the bitset.&lt;/p&gt;
&lt;p&gt;As an added bonus, if no deletion operation has been conducted since the last initialisation/clearance, the elements inÂ ğ‘‘[0..(ğ‘›âˆ’1)]Â will be in the order that they are added, with the least recently added item inÂ ğ‘‘[0]Â and the most recent inÂ ğ‘‘[ğ‘›âˆ’1], just like a vector.&lt;/p&gt;
&lt;h1 id=&#34;full-implementation&#34;&gt;
    &lt;a href=&#34;#full-implementation&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Full Implementation
&lt;/h1&gt;&lt;p&gt;The following is a C++ template implementation of the sparse set that I have written. It tries to implement all functionalities of a vanilla C++ bitset.&lt;/p&gt;
&lt;p&gt;Some implementation details:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The type of data this implementation of the sparse set stores isÂ &lt;code&gt;std::size_t&lt;/code&gt;, just like the STL bitset.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Like the STL bitset, usingÂ &lt;code&gt;[]&lt;/code&gt;Â to access and modify elements is supported. The semantics are the same as a STL bitset.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;test&lt;/code&gt;,Â &lt;code&gt;set&lt;/code&gt;,Â &lt;code&gt;reset&lt;/code&gt;, andÂ &lt;code&gt;flip&lt;/code&gt;Â all throwÂ &lt;code&gt;std::out_of_range&lt;/code&gt;Â if the parameter is greater than or equal toÂ ğ‘. However, usingÂ &lt;code&gt;[]&lt;/code&gt;Â to access elements with out-of-range indices results in undefined behaviour.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterators are supported and iterate through all elements in the set. The values they point to are immutable.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This also means you can use a range-for loop to access all elements of a sparse set.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Full code&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;array&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstddef&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;exception&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;limits&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_t N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sparse_set&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; size_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sparse_set()&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; n_{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;}, d_{}, s_{} {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sparse_set(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; bits)&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; sparse_set() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;min&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_type&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(N, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;digits); i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((bits &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; i) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                set(i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; other) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; other[i]) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reference&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; s;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        size_type pos;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        reference&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; b) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (b) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;set(pos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;reset(pos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flip&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;flip(pos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bool&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) s)[pos];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;iterator&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sparse_set&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; s;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        size_type idx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;(iterator other) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;s) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;other.s; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; other.s &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; other.idx; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            idx&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;n_) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        iterator &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; prev &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; prev;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        size_type &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;d_[idx];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;[](size_type i) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s_[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; s_[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n_ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; d_[s_[i]] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    reference &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;[](size_type i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; reference{&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, i};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;(size_type i) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; N) { &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;out_of_range{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;test(): argument out of range&amp;#34;&lt;/span&gt;}; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;all&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n_ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; N; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;any&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n_ &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;none&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n_ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    size_type &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n_; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    size_type &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; N; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            set(i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(size_type i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (test(i)) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d_[n_] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s_[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n_;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        n_&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reset&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        n_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reset&lt;/span&gt;(size_type i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;test(i)) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d_[s_[i]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; d_[n_&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        s_[d_[n_&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s_[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        n_&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flip&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flip(i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flip&lt;/span&gt;(size_type i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (test(i)) { reset(i); }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { set(i); }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    iterator &lt;span style=&#34;color:#a6e22e&#34;&gt;begin&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n_ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; iterator{&lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; iterator{&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; iterator &lt;span style=&#34;color:#a6e22e&#34;&gt;begin&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n_ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; iterator{&lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; iterator{&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    iterator &lt;span style=&#34;color:#a6e22e&#34;&gt;end&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; iterator{&lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; iterator &lt;span style=&#34;color:#a6e22e&#34;&gt;end&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; iterator{&lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    size_type n_;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_type, N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; d_;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_type, N&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; s_;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;
    &lt;a href=&#34;#conclusion&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Conclusion
&lt;/h1&gt;&lt;p&gt;While the sparse set data structure is rather obscure and almost never used in competitive programming, I think it can be useful in quite a few scenarios. In particular, it can be used as a more performant and hack-resistant version ofÂ &lt;code&gt;std::set&lt;/code&gt;Â andÂ &lt;code&gt;std::unordered_set&lt;/code&gt;Â when the only type of data that needs to be stored is small integers. I believe that many of its applications already have alternatives in the STL, however.&lt;/p&gt;
&lt;p&gt;So, the above is just a little data structure that I would like to share with you all. If you have any feedback regarding the content or the format (by the way, I really need a better method of creating these diagrams), please kindly leave it in the comments below. Thank you so much for reading all the way here!&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;
    &lt;a href=&#34;#references&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    References
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;List of references&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Most of this article&amp;rsquo;s content is taken fromÂ &lt;a class=&#34;link&#34; href=&#34;https://research.swtch.com/sparse&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;this website&lt;/a&gt;, which provides some interesting history and a great summary of this structure, forming the basis of this article.&lt;/p&gt;
&lt;p&gt;Other sources referenced:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://skypjack.github.io/2020-08-02-ecs-baf-part-9/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://skypjack.github.io/2020-08-02-ecs-baf-part-9/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://manenko.com/2021/05/23/sparse-sets.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://manenko.com/2021/05/23/sparse-sets.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>[C&#43;&#43;] Some programming language tips and tricks</title>
        <link>http://localhost:1313/post/cpp_tips_and_tricks/</link>
        <pubDate>Sat, 17 Feb 2024 17:09:01 +0800</pubDate>
        
        <guid>http://localhost:1313/post/cpp_tips_and_tricks/</guid>
        <description>&lt;p&gt;åŸæ–‡é“¾æ¥ï¼š&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://codeforces.com/blog/entry/126011&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[C++] Some programming language tips and tricks - Codeforces&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hello, Codeforces!&lt;/p&gt;
&lt;p&gt;Here are some language tips and tricks I have discovered that could (hopefully) help you write more concise or efficient code. Note that all of the below tips are specific to the C++ programming language and the STL library.&lt;/p&gt;
&lt;h1 id=&#34;creating-astdsetorstdmapfrom-sorted-data-inğ‘‚ğ‘›time&#34;&gt;
    &lt;a href=&#34;#creating-astdsetorstdmapfrom-sorted-data-in%f0%9d%91%82%f0%9d%91%9btime&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Creating aÂ std::setÂ orÂ std::mapÂ from sorted data inÂ ğ‘‚(ğ‘›)Â time
&lt;/h1&gt;&lt;p&gt;The sorted containersÂ &lt;code&gt;set&lt;/code&gt;Â andÂ &lt;code&gt;map&lt;/code&gt;Â are usually implemented as redâ€“black trees, meaning that theirÂ &lt;code&gt;insert&lt;/code&gt;Â operation runs inÂ ğ‘‚(logğ‘›)Â time by default. Naturally, repeating theÂ &lt;code&gt;insert&lt;/code&gt;Â operationÂ ğ‘›Â times would result in a time complexity ofÂ ğ‘‚(ğ‘›logğ‘›).&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; a = /* ... */;
set&amp;lt;int&amp;gt; s1;
for (int e : a) { s1.insert(e); } // O(n log n)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However,Â &lt;code&gt;set&lt;/code&gt;Â andÂ &lt;code&gt;map&lt;/code&gt;Â also provide a constructor method, that directly constructs the data structure from a given pair of iterators. In most implementations of C++, if the data contained within the range is already sorted, the constructor instead runs inÂ ğ‘‚(ğ‘›)Â time.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; a = /* some sorted data */;
set&amp;lt;int&amp;gt; s2(a.begin(), a.end()); // O(n)
int arr[n + 10] = /* more sorted data */;
set&amp;lt;int&amp;gt; s3(&amp;amp;arr[1], &amp;amp;arr[n] + 1); // ditto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is a simple benchmark code that I have written to illustrate the above performance difference. The code generatesÂ ğ‘›Â integers in the rangeÂ [0,ğ‘›], sorts them, then inserts them to sets using the two above methods. It can be seen, that theÂ ğ‘‚(ğ‘›)Â method generally runs in half the time of theÂ ğ‘‚(ğ‘›logğ‘›) method:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Benchmark code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;%5BC&amp;#43;&amp;#43;%5D%20Some%20programming%20language%20tips%20and%20tricks%201e4c7cb0026844f4aa308d1b432fdae4/bm.cpp&#34; &gt;bm.cpp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Results (nanoseconds)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If directly constructing the set (or map) is not possible (e.g. due to prior operations needing to be done on the set, or due to the data being online, etc.), the C++Â &lt;code&gt;set&lt;/code&gt;Â container provides an overload of theÂ &lt;code&gt;.insert()&lt;/code&gt;Â method that allows you to also specify a &amp;lsquo;hint&amp;rsquo; iterator, which points to the element just greater than the element to be inserted. In other words, ifÂ &lt;code&gt;e&lt;/code&gt;Â is to be inserted intoÂ &lt;code&gt;s&lt;/code&gt;, this &amp;lsquo;hint&amp;rsquo; iterator should be equal toÂ &lt;code&gt;s.lower_bound(e)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the given hint iterator happens to be correct, then theÂ &lt;code&gt;.insert()&lt;/code&gt;Â call runs in amortisedÂ ğ‘‚(1)Â time. Otherwise, the call still runs inÂ &lt;code&gt;O(\log n)&lt;/code&gt;Â time but may be slower than the regularÂ &lt;code&gt;.insert()&lt;/code&gt;Â call.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;s.insert(s.lower_bound(10), 10);// The &amp;#39;insert&amp;#39; operation itself runs in amortised O(1) time
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above example is not very helpful, since theÂ &lt;code&gt;.lower_bound()&lt;/code&gt;Â call itself already takesÂ ğ‘‚(logğ‘›)Â time, defeating the entire purpose of the optimisation. However, this can be useful if we already have extra information about the position of the to-be-added element. In particular,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the elementÂ &lt;code&gt;e&lt;/code&gt;Â is greater than all elements currently inÂ &lt;code&gt;s&lt;/code&gt;, we can writeÂ &lt;code&gt;s.insert(s.end(), e)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Similarly, if the elementÂ &lt;code&gt;e&lt;/code&gt;Â is less than all elements currently inÂ &lt;code&gt;s&lt;/code&gt;, we can writeÂ &lt;code&gt;s.insert(s.begin(), e)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similar operations can also be done on theÂ &lt;code&gt;map&lt;/code&gt;Â data structure, except that the second argument (element to be inserted) now needs to be a key-valueÂ &lt;code&gt;std::pair&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;reducing-the-number-of-memory-allocations-usingreserve&#34;&gt;
    &lt;a href=&#34;#reducing-the-number-of-memory-allocations-usingreserve&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Reducing the number of memory allocations usingÂ .reserve()
&lt;/h1&gt;&lt;p&gt;In the vast majority of C++ STL implementations, the containersÂ &lt;code&gt;vector&lt;/code&gt;Â andÂ &lt;code&gt;string&lt;/code&gt;Â have an internal buffer that is used to store data. Whenever a new element needs to be inserted while this buffer is full, the data structure first allocates a new, larger buffer, copies all data over to it, and then deallocates the original buffer. Whenever this occurs with aÂ &lt;code&gt;.push_back()&lt;/code&gt;Â call, the time taken for that call would beÂ ğ‘‚(ğ‘›). Since such memory reallocations can be very expensive, it would be ideal if we could decrease the number of reallocations.&lt;/p&gt;
&lt;p&gt;TheÂ &lt;code&gt;.reserve()&lt;/code&gt;Â method, available for bothÂ &lt;code&gt;vector&lt;/code&gt;s andÂ &lt;code&gt;string&lt;/code&gt;s, can lessen the frequency of reallocations by making the data structure expand its buffer to a provided size. For instance, ifÂ &lt;code&gt;v&lt;/code&gt;Â is a vector,Â &lt;code&gt;v.reserve(10);&lt;/code&gt;Â expandsÂ &lt;code&gt;v&lt;/code&gt;&amp;rsquo;s internal buffer to have a size of at least 10.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.reserve()&lt;/code&gt;Â has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Iterators and references are invalidatedÂ &lt;em&gt;if and only if&lt;/em&gt;Â the provided size exceeds the current size of the buffer.&lt;/li&gt;
&lt;li&gt;If the buffer is already big enough, nothing happens.Â &lt;code&gt;.reserve()&lt;/code&gt;Â cannot be used to decrease the size of a container.&lt;/li&gt;
&lt;li&gt;If theÂ &lt;code&gt;.reserve()&lt;/code&gt;Â call did change the size of the buffer, the time taken would beÂ ğ‘‚(ğ‘›), whereÂ ğ‘›Â is the size of the buffer.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.reserve()&lt;/code&gt;Â only changes theÂ &lt;em&gt;internal&lt;/em&gt;Â size of the container, not theÂ &lt;em&gt;logical&lt;/em&gt;Â size. For instance, the following code segment is still illegal (undefined behaviour):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v(5, 1);// v has size 5
v.reserve(100);// v now has buffer size at least 100, but logically still size 5
v[10] = 20;// undefined behaviour
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is important to note that, sinceÂ &lt;code&gt;.reserve()&lt;/code&gt;Â calls themselves cause reallocations to occur, they should be used sparingly, preferably only once just after the declaration of the container itself. For instance, the following code is highly inefficient and, theoretically, would increases the time taken fromÂ ğ‘‚(ğ‘›)Â toÂ ğ‘‚(ğ‘›2):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int n;
cin &amp;gt;&amp;gt; n;
vector&amp;lt;int&amp;gt; a;
for (int i = 0; i &amp;lt; n; i++) {
    a.reserve(i + 1);
int e;
    cin &amp;gt;&amp;gt; e;
    a.push_back(e);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Correct version ($O(n)$)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Additionally, forÂ &lt;code&gt;string&lt;/code&gt;s, directly inputting it fromÂ &lt;code&gt;std::cin&lt;/code&gt;Â would also cause it to expand its buffer size dynamically. On Codeforces, many problems would give you the size of the string first before the string itself. In these scenarios, the following code can be written to read the string more effectively:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int n;
string s;
cin &amp;gt;&amp;gt; n;
s.reserve(n);
cin &amp;gt;&amp;gt; s;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, note that callingÂ &lt;code&gt;.reserve()&lt;/code&gt;Â with an argument exceeding the actual size of the container can cause memory to be wasted. If memory is critical but the exact size of the container is not known, we can use theÂ &lt;code&gt;.shrink_to_fit()&lt;/code&gt;Â method to reduce the buffer size to what is strictly necessary to carry the data:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;string s;
s.reserve(100);
cin &amp;gt;&amp;gt; s;
// s is likely to be less than 100 characters, therefore shrink to save memory
s.shrink_to_fit();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that, unlikeÂ &lt;code&gt;.reserve()&lt;/code&gt;,Â &lt;code&gt;.shrink_to_fit()&lt;/code&gt;Â isÂ &lt;strong&gt;not&lt;/strong&gt;Â guaranteed to have any effect on the container, though for most implementations, it does reduce the memory usage.&lt;/p&gt;
&lt;h1 id=&#34;the-macroonline_judge&#34;&gt;
    &lt;a href=&#34;#the-macroonline_judge&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    The macroÂ ONLINE_JUDGE
&lt;/h1&gt;&lt;p&gt;When a piece of C++ code is run on Codeforces, the platform automatically defines a macroÂ &lt;code&gt;ONLINE_JUDGE&lt;/code&gt;. This can be useful in a variety of scenarios when you want to differentiate whether the code is being tested on your device or being judged online.&lt;/p&gt;
&lt;p&gt;For instance, a common optimisation for improving I/O efficiency is to untie the standard streamsÂ &lt;code&gt;cin&lt;/code&gt;Â andÂ &lt;code&gt;cout&lt;/code&gt;Â using the following line of code:Â &lt;code&gt;cin.tie(0)&lt;/code&gt;. By default, C++ flushes theÂ &lt;code&gt;cout&lt;/code&gt;Â stream whenever an input operation is performed, so that the user can see the output before being requested to input. While this would slow down the program and increase the running time, it could still be a useful feature to have when testing the code. Therefore, we can conditionally enable this optimisation using the following code segment:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#ifdef ONLINE_JUDGE
    cin.tie(nullptr);
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This way, the output is not affected when the code is being run on your local device. Be careful not to misspellÂ &lt;code&gt;ONLINE_JUDGE&lt;/code&gt;! Otherwise the optimisation will not be applied anywhere and may cause great performance penalties.&lt;/p&gt;
&lt;p&gt;Another common usage ofÂ &lt;code&gt;ONLINE_JUDGE&lt;/code&gt;Â is writing debug output functions. You can write a debugging function that only outputs toÂ &lt;code&gt;cout&lt;/code&gt;Â when not officially submitted and judged using the following code template:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void debug(/* any parameters */) {
#ifndef ONLINE_JUDGE
// code that produces debug output#endif
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;TheÂ &lt;code&gt;debug&lt;/code&gt;Â function can now be used anywhere inside your code to produce output only when testing. When judging, the function is a no-op. Be careful not to mix up the preprocessor directives â€” here it isÂ &lt;code&gt;ifndef&lt;/code&gt;Â instead ofÂ &lt;code&gt;ifdef&lt;/code&gt;, which causes the code that follows to be compiled only when the macro isÂ &lt;strong&gt;not&lt;/strong&gt;Â defined.&lt;/p&gt;
&lt;h1 id=&#34;explicit-types-forminandmax&#34;&gt;
    &lt;a href=&#34;#explicit-types-forminandmax&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Explicit types forÂ minÂ andÂ max
&lt;/h1&gt;&lt;p&gt;By default, the functionsÂ &lt;code&gt;min&lt;/code&gt;Â andÂ &lt;code&gt;max&lt;/code&gt;Â fromÂ &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;Â cause compile errors when the arguments are not of the same type. For instance, the below statements all cause compilation failures:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;min(3, 2.5);
max(4, 7LL);
min(&amp;#39;a&amp;#39;,&amp;#39;d&amp;#39; + 1);
max(10, a.size());// a is a container
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In these cases, you can explicitly specify a type for both parameters to be converted to in order to compile. Beware of losses to range/precision, however.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;min&amp;lt;double&amp;gt;(3, 2.5);
max&amp;lt;longlong&amp;gt;(4, 7LL);
min&amp;lt;char&amp;gt;(&amp;#39;a&amp;#39;,&amp;#39;d&amp;#39; + 1);// narrows the second argument, which is an int
max&amp;lt;int&amp;gt;(10, a.size());// technically narrows a.size() but usually won&amp;#39;t matter
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;lambda-comparator-forpriority_queue&#34;&gt;
    &lt;a href=&#34;#lambda-comparator-forpriority_queue&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Lambda comparator forÂ priority_queue
&lt;/h1&gt;&lt;p&gt;You can create aÂ &lt;code&gt;priority_queue&lt;/code&gt;Â whose comparator function is a lambda without having to create a separate class. For instance, to create aÂ &lt;code&gt;priority_queue&lt;/code&gt;Â for Dijkstra&amp;rsquo;s algorithm where entries are stored as nodeâ€“distance pairs, one can write:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;using ll =longlong;
usingentry_t = pair&amp;lt;int, ll&amp;gt;;

auto cmp = [](entry_t a,entry_t b) {return a.second &amp;gt; b.second; };
priority_queue&amp;lt;entry_t, vector&amp;lt;entry_t&amp;gt;,decltype(cmp)&amp;gt; q(cmp);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In my opinion, this is more natural than using (negative distance)â€“node pairs, for which the default sorting would have worked, but I find it more difficult to work with and possibly more bug-prone.&lt;/p&gt;
&lt;h1 id=&#34;miscellaneous-helpful-stl-functions&#34;&gt;
    &lt;a href=&#34;#miscellaneous-helpful-stl-functions&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Miscellaneous helpful STL functions
&lt;/h1&gt;&lt;p&gt;The following are some lesser-known STL functions that I have found useful in a variety of scenarios. I find that they can make code more concise by a considerable degree.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;div&lt;/code&gt;Â andÂ &lt;code&gt;lldiv&lt;/code&gt;Â (&lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;): takes two integer arguments (int for div, long long for lldiv), returns a structure that contains the quotient and the remainder but only takes one operation. Can be unpacked using structured bindings: auto [quot, rem] = div(a, b);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduce&lt;/code&gt;Â (&lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt;): given a range (an iterator pair), returns the sum of all elements in it. Beware of arithmetic overflows, however.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minmax_element&lt;/code&gt;Â (&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;): given a range, returns a pair of iterators (pointers for arrays) to the minimum and maximum element inside that range. This is usually better than two separate calls to min_element and max_element since the range is traversed only once. Can be unpacked using structured bindings, too.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inclusive_scan&lt;/code&gt;Â andÂ &lt;code&gt;exclusive_scan&lt;/code&gt;Â (&lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt;): generates the prefix sum for a range. The nth output of inclusive_scan includes the nth element in the sum, while that of exclusive_scan does not.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap&lt;/code&gt;Â (&lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;): swaps two elements. Though we can implement swapping ourselves in merely 3 lines, the frequency of this operation makes this function still useful. Additionally, swaps for container classes such as vectors or strings are usually more optimised than swapping via a temporary variable since most implementations of STL allow swaps to access the innards of these structures.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;
    &lt;a href=&#34;#conclusion&#34; class=&#34;header-anchor&#34;&gt;#&lt;/a&gt;
    Conclusion
&lt;/h1&gt;&lt;p&gt;So, the above is some C++ tips that I would like to share with you all. If you have any feedback regarding the content or the format, please kindly leave them in the comments below. Thank you very much for reading this far!&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
